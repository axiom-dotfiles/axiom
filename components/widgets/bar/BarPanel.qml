// BarPanel.qml
pragma ComponentBehavior: Bound

import Quickshell
import Quickshell.Wayland
import QtQuick

import qs.config
import qs.components.widgets.bar.modules as Widgets
import qs.components.widgets.popouts
import qs.components.reusable

PanelWindow {
  id: root

  required property var barConfig

  screen: Quickshell.screens.find(s => s.name === barConfig.display) || null
  WlrLayershell.layer: WlrLayer.Top
  WlrLayershell.exclusiveZone: barConfig.autoHide ? 0 : barConfig.extent
  WlrLayershell.namespace: "axiom-bar"

  // --- ANCHORS: Unchanged, as requested ---
  anchors {
    top: (barConfig.top || barConfig.vertical)
    bottom: (barConfig.bottom || barConfig.vertical)
    left: (barConfig.left || !barConfig.vertical)
    right: (barConfig.right || !barConfig.vertical)
  }

  visible: barConfig.enabled

  implicitHeight: barConfig.vertical ? 0 : barConfig.extent
  implicitWidth: barConfig.vertical ? barConfig.extent : 0

  Component.onCompleted: {
    console.log("=== BAR PANEL ===");
    console.log("Screen:", barConfig.display, "->", screen ? "Found" : "Not Found");
    console.log("Panel width:", width, "height:", height);
    console.log("Visible:", visible);
    console.log("implicitWidth:", implicitWidth, "implicitHeight:", implicitHeight);
    console.log("configuration:", JSON.stringify(barConfig));
  }

  // --- Dynamic Widget Logic ---

  // 1. Map widget type strings from JSON to the actual, imported QML component types.
  // This allows us to access the component variables directly without using strings.
  readonly property var widgetComponentMap: {
    "Logo": "modules/Logo.qml",
    "Window": "modules/Window.qml",
    "Media": "modules/Media.qml",
    "Workspaces": "modules/Workspaces.qml",
    "Time": "modules/Time.qml",
    "Tailscale": "modules/Tailscale.qml",
    "Network": "modules/Network.qml",
    "SystemTray": "modules/SystemTray.qml",
    "Battery": "modules/Battery.qml",
    "Notifications": "modules/Notifications.qml"
  }

  // 2. A factory function to build a model array for the WidgetGroup's Repeater.
  function buildWidgetModel(widgetConfigArray) {
    console.log("Building widget model for config:", JSON.stringify(widgetConfigArray));
    if (!widgetConfigArray || widgetConfigArray.length === 0) {
      return []; // Return an empty model for empty sections
    }

    const array = widgetConfigArray.filter(
      widgetConf => widgetConf.visible !== false).map(widgetConf => {
      console.log("Processing widget config:", JSON.stringify(widgetConf));
      const componentType = widgetComponentMap[widgetConf.type];
      console.log("Processing component type:", widgetConf.type, "->", componentType ? "Found" : "Not Found");
      console.log("ACTUAL component type:", componentType);
      if (!componentType) {
        console.warn("Unknown widget type in bar config:", widgetConf.type);
        return null;
      }

      console.log("Adding widget to model:", componentType, "with properties:", JSON.stringify(widgetConf.properties || {}));
      return {
        component: componentType
        ,
        properties: widgetConf.properties || {}
      };
    }).filter(item => item !== null); // Clean up any nulls from unknown widget types
    console.log("Final widget model array:", JSON.stringify(array));
    return array;
  }

  // --- UI Implementation ---

  PopoutWrapper {
    id: popouts
    screen: root.screen
  }

  BarContainer {
    anchors.fill: parent
    screen: root.screen
    popouts: popouts

    // TODO: Adjust this to support dynamic center widgets and workspace location for a fully
    // dynamic bar
    workspaces: Component {
      Widgets.Workspaces {
        visible: barConfig.widgets.center && barConfig.widgets.center.some(w => w.type === "Workspaces")
        screen: root.screen
        popouts: popouts
        orientation: barConfig.vertical ? Qt.Vertical : Qt.Horizontal
        panel: root
      }
    }
    // centerGroup: Component {
    //   WidgetGroup {
    //     vertical: root.barConfig.vertical
    //     model: root.buildWidgetModel(root.barConfig.widgets?.center)
    //   }
    // }

    // For all other groups, we create a Component containing a WidgetGroup,
    // and feed it the model generated by our function. This follows your original pattern.
    leftGroup: Component {
      WidgetGroup {
        vertical: root.barConfig.vertical
        model: {
          console.log("Left group config:", JSON.stringify(barConfig.widgets))
          let preModel = root.buildWidgetModel(root.barConfig.widgets?.left)
          console.log("Left group preModel:", JSON.stringify(preModel))
          return preModel;
          // buildWidgetModel(barConfig.widgets.left)
        }
      }
    }

    leftCenterGroup: Component {
      WidgetGroup {
        vertical: root.barConfig.vertical
        model: root.buildWidgetModel(root.barConfig.widgets?.leftCenter)
      }
    }

    rightCenterGroup: Component {
      WidgetGroup {
        vertical: root.barConfig.vertical
        model: root.buildWidgetModel(root.barConfig.widgets?.rightCenter)
      }
    }

    rightGroup: Component {
      WidgetGroup {
        vertical: root.barConfig.vertical
        model: {
          console.log("Right group config:", JSON.stringify(root.barConfig.widgets?.right))
          let preModel = root.buildWidgetModel(root.barConfig.widgets?.right)
          console.log("Right group preModel:", JSON.stringify(preModel))
          return preModel;
        }
      }
    }
  }
}
