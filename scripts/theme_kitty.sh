#!/usr/bin/env bash

#
# Quickshell Theme to Kitty Config Converter & Reloader (No-Flags Version)
#
# This script reads a Quickshell theme file, translates it into a Kitty
# terminal configuration, and reloads all running Kitty instances.
#
# It intelligently handles semantic colors, allowing them to be either
# direct hex codes or references to the base16 palette. It is also
# robust against missing or null values in the semantic block.
#
# Dependencies:
#   - jq:    For parsing the input JSON file.
#   - kitty: The script needs to be able to call `kitty @`.
#
# Usage:
#   ./theme-to-kitty.sh <input_file.json> [output_file.conf]
#

# --- Script Setup ---
set -e
set -u
set -o pipefail

# --- Dependency Check ---
if ! command -v jq &> /dev/null; then
    echo "Error: 'jq' is not installed. Please install it to use this script." >&2
    exit 1
fi
if ! command -v kitty &> /dev/null; then
    echo "Error: 'kitty' is not installed. Please install it to use this script." >&2
    exit 1
fi

# --- Functions ---
usage() {
    cat <<EOF
Usage: $(basename "$0") <input_file.json> [output_file.conf]

Converts a Quickshell JSON theme to a Kitty configuration file and reloads all
running Kitty instances.

Arguments:
  input_file.json   Path to the input Quickshell theme JSON file. (Required)
  output_file.conf  Path for the generated Kitty config file. (Optional)
                    Defaults to: ~/.config/kitty/theme/generated.conf
EOF
    exit 1
}

# --- Argument Parsing & Validation ---
if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    usage
fi

INPUT_FILE="$1"
DEFAULT_OUTPUT_PATH="$HOME/.config/kitty/theme/generated.conf"
OUTPUT_FILE="${2:-$DEFAULT_OUTPUT_PATH}"

if [ ! -f "$INPUT_FILE" ]; then
    echo "Error: Input file not found at '$INPUT_FILE'" >&2
    exit 1
fi

OUTPUT_DIR=$(dirname "$OUTPUT_FILE")
mkdir -p "$OUTPUT_DIR"

# --- Main Logic ---

echo "🎨 Reading theme from '$INPUT_FILE'..."

# This jq script is the core of the conversion.
# The `resolve` function has been improved to handle non-string inputs (like null)
# gracefully, preventing errors with incomplete theme files.
CONFIG_CONTENT=$(jq -r '
  # Helper function to resolve color names against a given palette.
  # It checks if the input is a string first, then if it exists as a key.
  # If the input is not a string (e.g., null), it returns an empty string.
  def resolve(palette):
    . as $key |
    if $key | type == "string" then
      if palette | has($key) then
        palette[$key]
      else
        $key
      end
    elif $key == null then
      ""
    else
      $key
    end;

  # Main filter
  .colors as $palette |
  [
    "# vim:ft=kitty",
    "#",
    "# This file was autogenerated by the theme conversion script.",
    "# Theme: \(.name)",
    "# Author: \(.author // "N/A")",
    "# Variant: \(.variant)",
    "",
    "# --- Main Colors ---",
    "foreground              \(.semantic.foreground | resolve($palette))",
    "background              \(.semantic.background | resolve($palette))",
    "selection_foreground    \(.semantic.background | resolve($palette))",
    "selection_background    \(.semantic.foreground | resolve($palette))",
    "url_color               \(.semantic.accent | resolve($palette))",
    "",
    "# --- Cursor ---",
    "cursor                  \(.semantic.accent | resolve($palette))",
    "cursor_text_color       \(.semantic.background | resolve($palette))",
    "",
    "# --- Borders ---",
    "active_border_color     \(.semantic.borderFocus | resolve($palette))",
    "inactive_border_color   \(.semantic.border | resolve($palette))",
    "bell_border_color       \(.semantic.warning | resolve($palette))",
    "",
    "# --- Tabs ---",
    "active_tab_foreground   \(.semantic.background | resolve($palette))",
    "active_tab_background   \(.semantic.borderFocus | resolve($palette))",
    "inactive_tab_foreground \(.semantic.foregroundInactive | resolve($palette))",
    "inactive_tab_background \(.semantic.backgroundAlt | resolve($palette))",
    "",
    "# --- ANSI Colors (Base16 Mapping) ---",
    "# Normal",
    "color0                  \($palette.base00)",
    "color1                  \($palette.base08)",
    "color2                  \($palette.base0B)",
    "color3                  \($palette.base0A)",
    "color4                  \($palette.base0D)",
    "color5                  \($palette.base0E)",
    "color6                  \($palette.base0C)",
    "color7                  \($palette.base05)",
    "",
    "# Bright",
    "color8                  \($palette.base03)",
    "color9                  \($palette.base09)",
    "color10                 \($palette.base0B)",
    "color11                 \($palette.base0A)",
    "color12                 \($palette.base0D)",
    "color13                 \($palette.base0E)",
    "color14                 \($palette.base0C)",
    "color15                 \($palette.base07)",
    ""
  ] | .[]
' < "$INPUT_FILE")

# Check if jq produced any output.
if [ -z "$CONFIG_CONTENT" ]; then
    echo "Error: Failed to parse JSON or extract required color keys from '$INPUT_FILE'." >&2
    echo "Please ensure the file is valid and conforms to the Quickshell Theme schema." >&2
    exit 1
fi

echo "📝 Writing Kitty config to '$OUTPUT_FILE'..."
echo "$CONFIG_CONTENT" > "$OUTPUT_FILE"

echo "🚀 Reloading all running Kitty instances..."

# Find all Kitty socket files and reload each one
SOCKET_FILES=$(ls /tmp/kitty-* 2>/dev/null || true)

if [ -z "$SOCKET_FILES" ]; then
    echo "⚠️  Warning: No Kitty instances found to reload." >&2
    echo "   This might be because no Kitty windows are open or remote control is disabled." >&2
    echo "   To enable it, add 'allow_remote_control yes' to your main kitty.conf." >&2
else
    RELOAD_SUCCESS=false
    for SOCKET in $SOCKET_FILES; do
        if [ -S "$SOCKET" ]; then  # Check if it's a socket
            echo "   Reloading via socket: $SOCKET"
            if kitty @ --to "unix:$SOCKET" set-colors --all --configured "$OUTPUT_FILE" 2>/dev/null; then
                RELOAD_SUCCESS=true
            fi
        fi
    done
    
    if [ "$RELOAD_SUCCESS" = false ]; then
        echo "⚠️  Warning: Could not reload any Kitty instances via remote control." >&2
        echo "   This might be because remote control is disabled." >&2
        echo "   To enable it, add 'allow_remote_control yes' to your main kitty.conf." >&2
    fi
fi
